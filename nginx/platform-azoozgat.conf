server {
    listen 80;
    server_name platform.azoozgat.com www.platform.azoozgat.com;
    root /actions-runner/_work/AzoozGAT-Platform/AzoozGAT-Platform/public;

    # Error pages
    # Ensure these files exist in the 'root' directory specified above.
    error_page 404 /404.html;
    location = /404.html {
        internal; # Prevents direct access to the error page URL
    }

    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        internal; # Prevents direct access to the error page URL
    }

    # Security headers
    # These are generally good to have.
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "same-origin" always;

    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Deny access to hidden files
    location ~ /\. {
        deny all;
        # access_log off; # Consider keeping access logs for denied requests for security auditing
        # log_not_found off;
    }

    # Proxy cache settings for the main application
    # These settings disable caching for dynamic content, which is generally correct.
    set $no_cache 1; # Default to not caching

    # Main location for application requests
    location / {
        # If a request is for a WebSocket upgrade, don't cache
        if ($http_upgrade != "") {
            set $no_cache 1;
        }

        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Controls caching for this location.
        # Your original settings effectively disable caching for dynamic content.
        # Using $no_cache variable can make it more explicit if you had more complex conditions.
        # proxy_cache_bypass $http_upgrade; # Good for WebSockets
        proxy_cache_bypass $no_cache $http_upgrade; # More general
        proxy_no_cache $no_cache $http_upgrade;     # Prevent storing responses that shouldn't be cached

        add_header Cache-Control "private, no-cache, no-store, must-revalidate";
        expires -1; # Equivalent to Cache-Control: no-cache

        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Specific handling for Next.js static assets (immutable, long cache)
    # This block will be matched before the more general regex locations below if the path starts with /_next/static/
    location /_next/static/ {
        # If you want Nginx to try serving from its 'root' first:
        # try_files $uri @proxy_static_next;
        # If all /_next/static/ assets are *always* served by the backend:
        proxy_pass http://localhost:3000/_next/static/;
        proxy_http_version 1.1; # Only needed if not inherited or if different from server default
        proxy_set_header Host $host; # Usually $host is sufficient, or use the upstream host if needed

        add_header Cache-Control "public, max-age=31536000, immutable";
        expires 1y; # Nginx specific, Cache-Control is preferred by modern browsers

        # Optional: If using try_files, you need the named location
        # access_log off; # Reduce logging for static assets
    }

    # Hashed JavaScript files (often for chunks with content hashes)
    # This should come before the generic .js rule
    location ~* \.([0-9a-f]{8,})\.(js|css)$ { # Combined JS and CSS hashed files
        # try_files $uri @proxy_static_assets; # If Nginx should try local first
        # If always from backend:
        proxy_pass http://localhost:3000$request_uri; # Pass the full original request URI
        proxy_http_version 1.1;
        proxy_set_header Host $host;

        add_header Cache-Control "public, max-age=31536000, immutable";
        expires 1y;
        # access_log off;
    }

    # General JavaScript files
    location ~* \.js$ {
        # try_files $uri @proxy_static_assets;
        # If always from backend:
        proxy_pass http://localhost:3000$request_uri;
        proxy_http_version 1.1;
        proxy_set_header Host $host;

        add_header Cache-Control "public, max-age=86400"; # 1 day
        expires 1d;
        # access_log off;
    }

    # Image files
    location ~* \.(?:jpg|jpeg|gif|png|ico|svg|webp)$ { # Using non-capturing group (?:...)
        # try_files $uri @proxy_static_assets;
        # If always from backend:
        proxy_pass http://localhost:3000$request_uri;
        proxy_http_version 1.1;
        proxy_set_header Host $host;

        add_header Cache-Control "public, max-age=604800"; # 7 days
        expires 7d;
        # access_log off;
    }

    # CSS and web font files
    location ~* \.(?:css|woff|woff2|ttf|eot)$ {
        # try_files $uri @proxy_static_assets;
        # If always from backend:
        proxy_pass http://localhost:3000$request_uri;
        proxy_http_version 1.1;
        proxy_set_header Host $host;

        add_header Cache-Control "public, max-age=86400"; # 1 day
        expires 1d;
        # access_log off;
    }

location @proxy {
        proxy_pass http://localhost:3000; # Ensure this is the correct address of your app
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host; # Pass the original host header
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme; # http or https

        # Timeouts for the proxy connection
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Gzip settings
    gzip on;
    gzip_comp_level 6; # Good balance
    gzip_min_length 256; # Don't gzip very small files
    gzip_proxied any; # Compress for all proxied requests
    gzip_vary on; # Adds "Vary: Accept-Encoding" header
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript # text/javascript is obsolete, but harmless
        application/javascript # Modern JS MIME type
        application/x-javascript # Older JS MIME type
        application/xml
        application/json
        image/svg+xml;
